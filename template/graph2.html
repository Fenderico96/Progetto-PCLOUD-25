<!DOCTYPE HTML>
<html>
    <head>
        <title>Graph</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <style> /*codice chiesto a gemini per migliorare la grafica degli sliders sul sito*/
            body {
                font-family: Arial, sans-serif;
                margin: 30px;
            }

            #sliderContainer {
                margin: 20px 0;
                display: flex; /* Use flexbox for horizontal alignment */
                justify-content: center; /* Center the items horizontally */
                align-items: center;
                gap: 20px; /* Space between items */
                flex-wrap: wrap;
                background-color: rgba(255, 255, 255, 0.08); /* Slightly more opaque for better visibility, adjust as needed */
                padding: 15px 25px; /* Increased padding */
                border-radius: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
                color: white; /* Ensure text is visible against the background */
            }

            #sliderContainer label {
                font-weight: bold;
                white-space: nowrap; /* Prevent labels from wrapping */
            }

            #sliderContainer input[type="range"] {
                flex-grow: 1; /* Allow sliders to take up available space */
                max-width: 300px; /* Limit slider width for better control */
                -webkit-appearance: none; /* Remove default slider styles for custom styling */
                appearance: none;
                height: 8px; /* Thinner track */
                background: rgba(255, 255, 255, 0.3); /* Lighter track color */
                outline: none;
                border-radius: 5px;
                transition: opacity .2s;
            }

            #sliderContainer input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px; /* Larger thumb */
                height: 20px; /* Larger thumb */
                background: #007bff; /* Blue thumb color, adjust to match your theme */
                cursor: pointer;
                border-radius: 50%; /* Circular thumb */
                border: 2px solid white; /* White border for contrast */
            }

            #sliderContainer input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                background: #007bff;
                cursor: pointer;
                border-radius: 50%;
                border: 2px solid white;
            }

            #sliderContainer span {
                min-width: 60px; /* Ensure time labels have consistent width */
                text-align: right;
            }
        </style>
    </head>
    <body class="is-preload">

        <header id="header">
                <a href="index.html" class="title">Hyperspace</a>
                <nav>
                    <ul>
                        <li><a href="hub.html">Home</a></li>
                        <li><a href="graph.html" class="active">Graph</a></li>
                        <li><a href="alarm.html">Alarm</a></li>
                        <li><a href="hub.html#three">Logout</a></li>
                    </ul>
                </nav>
            </header>

        <div id="wrapper">

                <section id="main" class="wrapper">
                        <div class="inner">
                            <h1 class="major">Graph</h1>
                            <canvas id="temperatureChart" height="100"></canvas>
                            <div id="sliderContainer">
                                <label for="startTime">From:</label>
                                <input type="range" id="startTime" min="0" max="23" value="0" />
                                <span id="startLabel">00:00</span>

                                <label for="endTime" style="margin-left: 20px;">To:</label>
                                <input type="range" id="endTime" min="0" max="23" value="23" />
                                <span id="endLabel">23:00</span>
                            </div>
                        </div>
                    </section>

            </div>

        <footer id="footer" class="wrapper alt">
                <div class="inner">
                    <ul class="menu">
                        <li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
                    </ul>
                </div>
            </footer>



            <script>
                // Dati fittizi: 24 letture orarie della temperatura
                const temperatureData = Array.from({ length: 24 }, (_, i) => ({
                    time: `${i.toString().padStart(2, '0')}:00`,
                    temp: 20 + Math.sin(i / 3) * 5 + Math.random() * 2 // Valori simulati
                }));

                // Dati fittizi per i problemi: Ora e il valore della temperatura al momento del problema
                const problemData = [
                    { time: '03:00', temp: 26.5, description: 'High Temp Alert' },
                    { time: '08:00', temp: 19.2, description: 'Low Temp Warning' },
                    { time: '15:00', temp: 28.0, description: 'Sensor Malfunction' },
                    { time: '20:00', temp: 27.1, description: 'High Temp Alert' }
                ];

                // --- NUOVE LINEE PER IL PADDING DEGLI ASSI ---
                const allTemperatures = [
                    ...temperatureData.map(d => d.temp),
                    ...problemData.map(d => d.temp)
                ];

                const minTemp = Math.min(...allTemperatures);
                const maxTemp = Math.max(...allTemperatures);

                const padding = 2; // Margine di 2 gradi sopra e sotto
                const suggestedMinY = minTemp - padding;
                const suggestedMaxY = maxTemp + padding;
                // --- FINE NUOVE LINEE ---


                const ctx = document.getElementById('temperatureChart').getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: temperatureData.map(d => d.time),
                        datasets: [
                            {
                                label: 'Temperature (째C)',
                                data: temperatureData.map(d => d.temp),
                                borderColor: 'white',
                                tension: 0.4,
                                fill: false
                            },
                            {
                                type: 'scatter',
                                label: 'Problems',
                                // Modifica qui: aggiungi la descrizione nel punto dati
                                data: problemData.map(d => ({ x: d.time, y: d.temp, description: d.description })),
                                backgroundColor: 'red',
                                borderColor: 'red',
                                pointRadius: 8,
                                pointHoverRadius: 10,
                                showLine: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'Temperature (째C)'
                                },
                                // Applica i valori calcolati per il padding
                                min: suggestedMinY,
                                max: suggestedMaxY
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                },
                                type: 'category'
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.dataset.type === 'scatter') {
                                            // Accedi direttamente alla descrizione dal punto dati
                                            label += `${context.raw.description || 'Nessuna descrizione'} (${context.parsed.y}째C)`;
                                        } else {
                                            label += `${context.parsed.y}째C`;
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });

                // Filtro per fascia oraria con slider
                const startSlider = document.getElementById('startTime');
                const endSlider = document.getElementById('endTime');
                const startLabel = document.getElementById('startLabel');
                const endLabel = document.getElementById('endLabel');

                function updateChart() {
                    let start = parseInt(startSlider.value);
                    let end = parseInt(endSlider.value);

                    if (start > end) [start, end] = [end, start];

                    const filteredTemperature = temperatureData.slice(start, end + 1);
                    const filteredProblems = problemData.filter(p => {
                        const problemHour = parseInt(p.time.split(':')[0]);
                        return problemHour >= start && problemHour <= end;
                    });

                    chart.data.labels = filteredTemperature.map(d => d.time);
                    chart.data.datasets[0].data = filteredTemperature.map(d => d.temp);
                    // Modifica anche qui per la descrizione
                    chart.data.datasets[1].data = filteredProblems.map(d => ({ x: d.time, y: d.temp, description: d.description }));


                    // --- Ricalcola min/max per il padding solo per i dati filtrati ---
                    const currentAllTemperatures = [
                        ...filteredTemperature.map(d => d.temp),
                        ...filteredProblems.map(d => d.temp)
                    ];

                    // Se non ci sono dati nel range filtrato, evita errori con Math.min/max
                    if (currentAllTemperatures.length > 0) {
                        const currentMinTemp = Math.min(...currentAllTemperatures);
                        const currentMaxTemp = Math.max(...currentAllTemperatures);

                        chart.options.scales.y.min = currentMinTemp - padding;
                        chart.options.scales.y.max = currentMaxTemp + padding;
                    } else {
                        // Se non ci sono dati, puoi impostare un range predefinito o lasciare che Chart.js decida
                        chart.options.scales.y.min = 0; // Esempio: imposta un minimo
                        chart.options.scales.y.max = 30; // Esempio: imposta un massimo
                    }
                    // --- FINE RICALCOLO ---

                    chart.update();

                    startLabel.textContent = `${start.toString().padStart(2, '0')}:00`;
                    endLabel.textContent = `${end.toString().padStart(2, '0')}:00`;
                }

                startSlider.addEventListener('input', updateChart);
                endSlider.addEventListener('input', updateChart);

                updateChart(); // Inizializzazione
            </script>
        <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.scrollex.min.js"></script>
            <script src="assets/js/jquery.scrolly.min.js"></script>
            <script src="assets/js/browser.min.js"></script>
            <script src="assets/js/breakpoints.min.js"></script>
            <script src="assets/js/util.js"></script>
            <script src="assets/js/main.js"></script>

    </body>
</html>